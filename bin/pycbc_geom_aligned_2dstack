#!/usr/bin/env python

# Copyright (C) 2011 Ian W. Harry
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 3 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

"""
This program takes a list of potential points in the xi parameter space, and
the files that define the parameter space, and then:
1) Removes points that are too far away from the physical region of interest
2) Identifies the closest physical point to the desired position for all
remaining points.
3) Dumps these physical coordinates back to file
It also prints information about the discarded points for debugging.
"""

from __future__ import division
import time
start = int(time.time()*10**6)
elapsed_time = lambda: int(time.time()*10**6-start)

import os,sys,optparse,copy
import numpy
import pycbc.tmpltbank
import pycbc.version

__author__  = "Ian Harry <ian.harry@ligo.org>"
__version__ = pycbc.version.git_verbose_msg
__date__    = pycbc.version.date
__program__ = "pycbc_geom_aligned_2dstack"

# Feed in command line options
usage = """usage: %prog [options]"""
_desc = __doc__[1:]
parser = optparse.OptionParser(usage, version=__version__, description=_desc)
parser.add_option("-v", "--verbose", action="store_true", default=False,\
                    help="verbose output, default: %default")
parser.add_option("-b", "--input-bank-file", action="store", type="string",\
                   default=None,\
                   help="ASCII file containing the input bank.")
parser.add_option("-B", "--output-bank-file", action="store", type="string",\
                   default=None,\
                   help="ASCII file containing the output bank.")
parser.add_option("-o", "--pn-order", action="store", type="string",\
                   default=None,\
                   help="""Determines the PN order to use, choices are:
    * "twoPN": will include spin and non-spin terms up to 2PN in phase
    * "threePointFivePN": will include non-spin terms to 3.5PN, spin to 2.5PN
    * "taylorF4_45PN": use the R2D2 metric with partial terms to 4.5PN""")
parser.add_option("-m", "--metric-evals-file", action="store", type="string",\
                   default=None,\
                   help="ASCII file containing the metric eigenvalues.")
parser.add_option("-M", "--metric-evecs-file", action="store", type="string",\
                   default=None,\
                   help="ASCII file containing the metric eigenvectors.")
parser.add_option("-N", "--cov-evecs-file", action="store", type="string",\
                   default=None,\
                   help="ASCII file containing the covariance eigenvectors.")
parser.add_option("-f", "--f0", action="store", type="float",\
                  default=70., help="f0 for use in metric calculation," +\
                                    "default: %default")
parser.add_option("-y", "--min-mass1", action="store", type="float",\
                  default=0.03, help="Minimum mass1 to generate bank with"+\
                                     ", mass1 *must* be larger than mass2" +\
                                      "default: %default")
parser.add_option("-Y", "--max-mass1", action="store", type="float",\
                  default=0.03, help="Maximum mass1 to generate bank with"+\
                                      "default: %default")
parser.add_option("-z", "--min-mass2", action="store", type="float",\
                  default=0.03, help="Minimum mass2 to generate bank with"+\
                                      "default: %default")
parser.add_option("-Z", "--max-mass2", action="store", type="float",\
                  default=0.03, help="Maximum mass2 to generate bank with"+\
                                      "default: %default")
parser.add_option("", "--max-total-mass", action="store", type="float",\
                  default=None, help="Minimum total mass to generate bank "+\
                                      "with default: %default")
parser.add_option("", "--min-total-mass", action="store", type="float",\
                  default=None, help="Maximum total mass to generate bank "+\
                                      "with default: %default")
parser.add_option("-x", "--max-ns-spin-mag", action="store", type="float",\
                  default=0.03, help="Maximum neutron star spin magnitude"+\
                                      "default: %default")
parser.add_option("-X", "--max-bh-spin-mag", action="store", type="float",\
                  default=0.03, help="Maximum black hole spin magnitude"+\
                                      "default: %default")
parser.add_option("-O", "--min-match", action="store", type="float",\
                  default=0.03, help="Minimum match to generate bank with"+\
                                      "default: %default")
parser.add_option("-n", "--nsbh-flag", action="store_true", default=False,\
                    help="Set this if running with NSBH, default: %default")
parser.add_option("-s", "--stack-distance", action="store", type="float",\
                  default=0.2, help="Minimum metric spacing before we stack"+\
                                      "default: %default")
parser.add_option("-3", "--threed-lattice", action="store_true", default=False,\
                    help="Set this to use a 3D lattice, default: %default")
parser.add_option("-a", "--skip-vec4-depth",action="store_true", default=False,\
    help="Assume the 4th direction to have negligible depth, default: %default")
parser.add_option("-F", "--skip-vec5-depth",action="store_true", default=False,\
    help="Assume the 5th direction to have negligible depth, default: %default")


(opts,args) = parser.parse_args()
opts.eval_vec4_depth = not opts.skip_vec4_depth
opts.eval_vec5_depth = not opts.skip_vec5_depth

# If we only have 4 directions, do not try to evaluate the fifth!
if opts.pn_order == 'twoPN':
    opts.eval_vec5_depth = False

# Load the list of points from file
tempBank = numpy.loadtxt(opts.input_bank_file)

# Load the files giving the information needed to define the xi_i
# parameter space
evals = numpy.loadtxt(opts.metric_evals_file)
evecs = numpy.matrix(numpy.loadtxt(opts.metric_evecs_file))
evecsCV = numpy.matrix(numpy.loadtxt(opts.cov_evecs_file))

# Create a large set of points and map to xi_i to give a starting point when
# mapping from xi_i to masses and spins
rTotmass, rEta, rBeta, rSigma, rGamma, rSpin1z, rSpin2z = \
      pycbc.tmpltbank.get_random_mass(
      2000000, opts.min_mass1, opts.max_mass1, opts.min_mass2, opts.max_mass2,\
      opts.max_ns_spin_mag, maxBHspin=opts.max_bh_spin_mag, \
      minTotalMass=opts.min_total_mass, maxTotalMass=opts.max_total_mass)
diff = (rTotmass*rTotmass * (1-4*rEta))**0.5
rMass1 = (rTotmass + diff)/2.
rMass2 = (rTotmass - diff)/2.
rChis = (rSpin1z + rSpin2z)/2.

rXis = pycbc.tmpltbank.get_cov_params(rTotmass, rEta, rBeta, rSigma, rGamma,\
           rChis, opts.f0, evecs, evals, evecsCV, opts.pn_order)

xis = (numpy.array(rXis)).T
physMasses = numpy.array([rTotmass, rEta, rSpin1z, rSpin2z])
physMasses = physMasses.T
f0 = opts.f0
order = opts.pn_order
maxmass1 = opts.max_mass1
maxmass2 = opts.max_mass2
minmass1 = opts.min_mass1
minmass2 = opts.min_mass2
maxNSspin = opts.max_ns_spin_mag
maxBHspin = opts.max_bh_spin_mag

# Here we start looping over bank
temp_number = 0
outFile = opts.output_bank_file
outPointer = open(outFile,'w')
outPointer2 = open(outFile+'.reject','w')
outPointer3 = open(outFile+'.depths','w')
numtemps = len(tempBank)
for entry in tempBank:
    temp_number += 1
    if opts.verbose:
        print "Analysing template %d" %(temp_number)
    # First find the closest point in our set of 2000000 defined above 
    # This is used as the starting point
    xi1_des = entry[0]
    xi2_des = entry[1]
    xis_des = [xi1_des,xi2_des]
    if opts.threed_lattice:
        xi3_des = entry[2]
        xis_des.append(xi3_des)
    req_match = 0.0001
    dist = (xi1_des - xis[:,0])**2 + (xi2_des - xis[:,1])**2
    if opts.threed_lattice:
        dist += (xi3_des - xis[:,2])**2
    xis_close = xis[dist < 0.03]
    masses_close = physMasses[dist < 0.03]
    bestMasses = physMasses[dist.argmin()]
    bestXis = xis[dist.argmin()]
    if opts.verbose:
        print "Template %d has initial distance of %e" \
              %(temp_number, dist.min())
    # Reject point if it is too far away from *any* of these points
    if dist.min() > 2.:
        if opts.verbose:
            print "Template %d rejected as too far away" %(temp_number)
        # Print info to the rejected points file
        if opts.threed_lattice:
            print >> outPointer2, "%e %e %e %e %e %e %e %e" \
                     %(xi1_des, xi2_des, xi3_des, 0, 0, 0, 0, dist.min())
        else:
            print >> outPointer2, "%e %e %e %e %e %e %e" \
                     %(xi1_des, xi2_des, 0, 0, 0, 0, dist.min())
        continue
    # This function will use the starting point and iteratively find a
    # physical point has a mismatch < 0.0001 with the desired one
    masses = pycbc.tmpltbank.get_physical_covaried_masses(xis_des,\
               copy.deepcopy(bestMasses), copy.deepcopy(bestXis), f0,\
               req_match, order, evecs, evals, evecsCV,\
               maxmass1, minmass1, maxmass2, minmass2, maxNSspin, maxBHspin,\
               nsbh_flag=opts.nsbh_flag, minTotalMass=opts.min_total_mass, \
               maxTotalMass=opts.max_total_mass)
    # Now how close is it?
    if opts.verbose:
        print "Template %d has corrected distance of %e"\
              %(temp_number, masses[5])
    if masses[5] > 0.05:
        # Reject point, it is too far away
        if opts.verbose:
            print "Template %d rejected as too far away" %(temp_number)
        if opts.threed_lattice:
            print >> outPointer2, "%e %e %e %e %e %e %e %e" \
                     %(xi1_des, xi2_des, xi3_des, masses[0], masses[1],\
                       masses[2], masses[3], masses[5])
        else:
            print >> outPointer2, "%e %e %e %e %e %e %e" \
                     %(xi1_des, xi2_des, masses[0], masses[1], masses[2],\
                       masses[3], masses[5])
        continue
    # If we got this far the point will be accepted.
    # Now we figure out if the depth of the *other* directions are wide enough
    # that we need to stack points
    # We begin by evaluating the depth of the third direction, this is not
    # needed if a 3D lattice is being employed
    tmpTotMass = masses[0] + masses[1]
    tmpEta = masses[0] * masses[1] / (tmpTotMass*tmpTotMass)
    if not opts.threed_lattice:
        # If point is close enough, determine depth of xi3 direction
        vec3_min, vec3_max=\
                pycbc.tmpltbank.stack_xi_direction_brute([masses[6],masses[7]],\
                  [tmpTotMass,tmpEta,masses[2],masses[3]],\
                  copy.deepcopy(bestXis), f0, 2, opts.min_match,\
                  order, evecs, evals, evecsCV, maxmass1, minmass1, maxmass2,\
                  minmass2, maxNSspin, maxBHspin, nsbh_flag=opts.nsbh_flag, \
                  minTotalMass=opts.min_total_mass, \
                  maxTotalMass=opts.max_total_mass)
        vec3_depth = vec3_max - vec3_min
        # Double check that no points appear outside what was calculated above
        if len(xis_close):
            if vec3_min > xis_close[:,2].min():
                print "WARNING: Numerical placement fails, trying again"
                temp_idx = xis_close[:,2].argmin()
                temmpBestMasses = masses_close[temp_idx]
                temmpBestXis = xis_close[temp_idx]
                temmpvec3_min, temmpvec3_max =\
                    pycbc.tmpltbank.stack_xi_direction_brute([xi1_des,xi2_des],\
                      copy.deepcopy(temmpBestMasses),\
                      copy.deepcopy(temmpBestXis), f0, 2,\
                      opts.min_match, order, evecs, evals, evecsCV, maxmass1,\
                      minmass1, maxmass2, minmass2, maxNSspin, maxBHspin,\
                      nsbh_flag=opts.nsbh_flag,\
                      minTotalMass=opts.min_total_mass, \
                      maxTotalMass=opts.max_total_mass)
                temmpvec3_depth = temmpvec3_max - temmpvec3_min
                if temmpvec3_min < vec3_min:
                    vec3_min = temmpvec3_min
                    vec3_depth = vec3_max - vec3_min
                if temmpvec3_max > vec3_max:
                    vec3_max = temmpvec3_max
                    vec3_depth = vec3_max - vec3_min
            if vec3_max < xis_close[:,2].max():
                print "WARNING: Numerical placement fails, trying again"
                temp_idx = xis_close[:,2].argmax()
                temmpBestMasses = physMasses[temp_idx]
                temmpBestXis = xis[temp_idx]
                temmpvec3_min, temmpvec3_max =\
                    pycbc.tmpltbank.stack_xi_direction_brute([xi1_des,xi2_des],\
                      copy.deepcopy(temmpBestMasses),\
                      copy.deepcopy(temmpBestXis), f0, 2,\
                      opts.min_match, order, evecs, evals, evecsCV, maxmass1,\
                      minmass1, maxmass2, minmass2, maxNSspin, maxBHspin,\
                      nsbh_flag=opts.nsbh_flag,\
                      minTotalMass=opts.min_total_mass, \
                      maxTotalMass=opts.max_total_mass)
                temmpvec3_depth = temmpvec3_max - temmpvec3_min
                if temmpvec3_max > vec3_max:
                    vec3_max = temmpvec3_max
                    vec3_depth = vec3_max - vec3_min
                if temmpvec3_min < vec3_min:
                    vec3_min = temmpvec3_min
                    vec3_depth = vec3_max - vec3_min
  # Determine depth of xi4 direction (is this needed is xi3 depth is found to
  # be small?)
    if opts.eval_vec4_depth:
        vec4_min, vec4_max =\
              pycbc.tmpltbank.stack_xi_direction_brute([masses[6],masses[7]],\
                [tmpTotMass,tmpEta,masses[2],masses[3]],\
                copy.deepcopy(bestXis), f0, 3, opts.min_match,\
                order, evecs, evals, evecsCV, maxmass1, minmass1, maxmass2,\
                minmass2, maxNSspin, maxBHspin, nsbh_flag=opts.nsbh_flag, \
                minTotalMass=opts.min_total_mass, \
                maxTotalMass=opts.max_total_mass)
        vec4_depth = vec4_max - vec4_min
    else:
        vec4_min = vec4_max = vec4_depth = 0
    # Determine depth of xi5 direction 
    if opts.eval_vec5_depth:
        vec5_min, vec5_max =\
              pycbc.tmpltbank.stack_xi_direction_brute([masses[6],masses[7]],\
                [tmpTotMass,tmpEta,masses[2],masses[3]],\
                copy.deepcopy(bestXis), f0, 4, opts.min_match,\
                order, evecs, evals, evecsCV, maxmass1, minmass1, maxmass2,\
                minmass2, maxNSspin, maxBHspin, nsbh_flag=opts.nsbh_flag, \
                minTotalMass=opts.min_total_mass, \
                maxTotalMass=opts.max_total_mass)
        vec5_depth = vec5_max - vec5_min
    else:
        vec5_min = vec5_max = vec5_depth = 0
    # Output depths
    if opts.threed_lattice:
        print >> outPointer3, "%e %e %e %e %e"\
                 %(xi1_des, xi2_des, xi3_des, vec4_depth, vec5_depth)
    else:
        print >> outPointer3, "%e %e %e %e %e"\
                 %(xi1_des, xi2_des, vec3_depth, vec4_depth, vec5_depth)
   # Figure out how many templates we need to stack in 3rd direction
    vec3DepthVal = opts.stack_distance
    if opts.threed_lattice:
        numV3Temps = 1
    else:
        numV3Temps = int(round(vec3_depth // vec3DepthVal)) + 1
    for ite in range(numV3Temps):
        if not opts.threed_lattice:
            xi3_des = vec3_min + \
                      (vec3_depth) * (2 * ite + 1) / (2. * (numV3Temps))
        dist = (xi1_des - xis[:,0])**2 + (xi2_des - xis[:,1])**2 + \
                (xi3_des - xis[:,2])**2
        bestMasses = physMasses[dist.argmin()]
        bestXis = xis[dist.argmin()]
        # Find close point to this 3d position
        masses = pycbc.tmpltbank.get_physical_covaried_masses(\
              [xi1_des,xi2_des,xi3_des], copy.deepcopy(bestMasses),\
              copy.deepcopy(bestXis), f0, req_match, order,\
              evecs, evals, evecsCV, maxmass1, minmass1, maxmass2, minmass2,\
              maxNSspin, maxBHspin, nsbh_flag=opts.nsbh_flag, \
              minTotalMass=opts.min_total_mass, \
              maxTotalMass=opts.max_total_mass)
        # If vec4 depth is negligible or we didn't get close, stop here
        if vec4_depth < vec3DepthVal or masses[5] > 0.03:
            if masses[5]:
                # Write point to file
                print >> outPointer, "%e %e %e %e %e" \
                      %(masses[0], masses[1], masses[2], masses[3], masses[5])
        else:
            # OR we need to estimate the depth in the 4th direction at this
            # 3d point
            tmpTotMass = masses[0] + masses[1]
            tmpEta = masses[0] * masses[1] / (tmpTotMass*tmpTotMass)
            vec4_minT, vec4_maxT = \
                  pycbc.tmpltbank.stack_xi_direction_brute(\
                    [masses[6],masses[7],masses[8]],\
                    [tmpTotMass,tmpEta,masses[2],masses[3]],\
                    copy.deepcopy(bestXis), f0, 3, opts.min_match,\
                    order, evecs, evals, evecsCV, maxmass1, minmass1, maxmass2,\
                    minmass2, maxNSspin, maxBHspin, nsbh_flag=opts.nsbh_flag, \
                    minTotalMass=opts.min_total_mass, \
                    maxTotalMass=opts.max_total_mass)
            vec4_depthT = vec4_maxT - vec4_minT
            # Then loop over necessary templates in 4th direction
            numV4Temps = int(round(vec4_depthT // vec3DepthVal)) + 1
            for ite in range(numV4Temps):
                xi4_des = vec4_minT + \
                          (vec4_depthT) * (2 * ite + 1) / (2. * (numV4Temps))
                dist = (xi1_des - xis[:,0])**2 + (xi2_des - xis[:,1])**2 + \
                       (xi3_des - xis[:,2])**2 + (xi4_des - xis[:,3])**2
                bestMasses = physMasses[dist.argmin()]
                bestXis = xis[dist.argmin()]
                masses = pycbc.tmpltbank.get_physical_covaried_masses(\
                      [xi1_des,xi2_des,xi3_des,xi4_des],\
                      copy.deepcopy(bestMasses), copy.deepcopy(bestXis), f0,\
                      req_match, order, evecs, evals, evecsCV,\
                      maxmass1, minmass1, maxmass2, minmass2, maxNSspin,\
                      maxBHspin, nsbh_flag=opts.nsbh_flag,\
                      minTotalMass=opts.min_total_mass, \
                      maxTotalMass=opts.max_total_mass)
                if masses[5]:
                    # Write point to file
                    print >> outPointer, "%e %e %e %e %e"\
                          %(masses[0], masses[1], masses[2], masses[3],\
                            masses[5])

outPointer.close()
