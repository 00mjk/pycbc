#!/usr/bin/python
#
# Copyright (C) 2011 Karsten Wiesner
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# pycbc should follow <http://www.python.org/dev/peps/pep-0008/>
#
# vim: tabstop=4:softtabstop=4:shiftwidth=4:expandtab

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

"""
Application of gravitational wave search for inspiral mergers based on the 
pycbc (py-thon c-ompact b-inary c-oalecence) package 

Single detector minimal pipeline used as prototype to test pycbc architecture
to incorporate:

- CUDA GPU implementation of CBC SPA waveform generator and 
  matched filter by Alex Nitz (Univerity of Syracuse)

- Open Cl GPU implementation of full CBC pipeline by Benjamin Somhegyi and
  Gergely Debreczeni (KFKI, RMKI Budapest)

"""

import sys
import random

# preliminary hard coded path to packages 
sys.path.append('/Users/kawies/dev/src/pycbc')

from pycbc.straindata.straindata_cpu import StrainDataCpu as StrainData 
from pycbc.templatebank.templatebank_cpu import TemplateBankCpu as TemplateBank 
from pycbc.matchedfilter.matchedfilter_cpu import MatchedFilterCpu as MatchedFilter
from pycbc.datavector.datavectorcpu import real_vector_single_t as SnrResultTimeSeries

import logging

logging.basicConfig(level=logging.DEBUG,
                    format='%(name)s %(asctime)s %(levelname)s %(message)s',
                    filename='pycbc_min_pipeline.log',
                    filemode='w')

logger= logging.getLogger('pycbc.main_script')


start_message = 'Starting pycbc single detector minimal pipeline ...'
logger.debug(start_message)
print start_message

# setup straindata
search_time = 128 # typ design spec: 2048
sample_freq = 256 # typ design spec: 4096
length =      search_time * sample_freq
segments = 15
gps_start_time= 871147532
gps_end_time= gps_start_time + search_time
interferometer = "H1"
        
strain_data= StrainData(gps_start_time, gps_end_time, 
                        segments, sample_freq, 
                        interferometer)
logger.debug("instanciated StrainData w/ segment length: {0}".format(strain_data.segments_length))

# initialize straindata w/ white noise
for i in range(length):
    tmp= random.uniform(-1,1)
    strain_data.time_series[i] = tmp

# convert straindata to single precision
strain_data.convert_to_single_preci()


# segmenting straindata and transform into frequency domain
strain_data.perform_fft_segments()

# transfer straindata to appropriate memory space on target device
strain_data.render()

# create 5 templates (testing the iterator of TemplateBank)
bank = TemplateBank( 5, strain_data.segments_length )
logger.debug("instanciated TemplateBank w/ waveform length: {0}".format(bank.waveform_length))


# create matched filter (only generate_snr() has to be implemented
# for the minimal pipeline)
matched_filter = MatchedFilter(strain_data.segments_length)
logger.debug("instanciated MatchedFilter w/ length: {0}".format(matched_filter.length))

# instanciate result vectors
snr = SnrResultTimeSeries(strain_data.segments_length)
logger.debug("instanciated SnrResultTimeSeries as {0}".format(repr(snr)))

# filter the data against the template bank
for template in bank:
    htilde = bank.perform_generate_waveform(template)
    for stilde in strain_data:
        matched_filter.perform_generate_snr(stilde, htilde, snr)

        
# Two different schemes of handling data buffers can be seen here:
#
# htilde = bank.perform_generate_waveform(template) 
# returns a datavector that is instanciated as a member of the bank object
# (<complex_vector_single_t, length 4096, data ptr 0x10090ae00>)
#
# pro: Input and output is clearly defined. Bank object (derivative) knows
# best the kind of datavector and it's size to instanciate it. datavector will
# be destroyed when bank is destructed (by calling the swigged destructor) 
#
# cons: ?
#
# matched_filter.perform_generate_snr(stilde, htilde, snr)
# stilde and htilde are input buffers, snr is the outputbuffer
# snr has to be instantiated in the script context:
# snr = SnrResultTimeSeries(strain_data.segments_length)
# 
# pro: ?
#
# cons: matched_filter object has to check against the type of the given 
# datavector (as well as for stilde and htilde). More efford to document
# what is the input and what ist the output.
#
 
end_message = '... end of pycbc single detector minimal pipeline.'
logger.debug(end_message)
print end_message
       




        
