#!/usr/bin/python
""" Make table of the foreground coincident events
"""
import argparse, h5py, numpy, logging, os.path
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plot, mpld3, mpld3.plugins, mpld3.utils

import pycbc.results.followup, pycbc.pnutils
from pycbc.results.mpld3_utils import ClickLink

parser = argparse.ArgumentParser()
parser.add_argument('--injection-file')
parser.add_argument('--injection-tag')
parser.add_argument('--verbose', action='count')
parser.add_argument('--output-file')
args = parser.parse_args()

def compute_sensitive_distance(f_dist, m_dist):
    """ Compute the sensitive volume
    """
    f_dist.sort()
    m_dist.sort()
    distances = numpy.concatenate([f_dist, m_dist])
    dist_sorting = distances.argsort()
    distances = distances[dist_sorting]
    
    low = 0
    vol = 0
    for i in range(len(distances)):
        if i == len(distances) - 1:
            break
    
        high = (distances[i+1] + distances[i]) / 2
        bin_width = high - low
        
        if dist_sorting[i] <= len(f_dist):
            vol += 4 * numpy.pi * distances[i]**2.0 * bin_width

        low = high
        
    dist = (vol * 3.0/4.0/numpy.pi) ** (1.0/3.0)
    print distances[-1], dist
    return dist

if args.verbose:
    log_level = logging.INFO
    logging.basicConfig(format='%(asctime)s : %(message)s', level=log_level)
    
logging.info('Read in the data')
f = h5py.File(args.injection_file, 'r')

time = f['injections/end_time'][:]
found = f['found_after_vetoes/injection_index'][:]
missed = f['missed/after_vetoes'][:]

ifar = f['found_after_vetoes/ifar'][:]

m1, m2 = f['injections/mass1'][:], f['injections/mass2'][:]
mchirp, eta = pycbc.pnutils.mass1_mass2_to_mchirp_eta(m1, m2)

# This hardcodes HL search !!!!!, replace with function that takes or/sky/det
hdist = f['injections/eff_dist_h'][:]
ldist = f['injections/eff_dist_l'][:]
dec_dist = numpy.maximum(hdist, ldist)
dist = f['injections/distance'][:]
m1, m2 = f['injections/mass1'][:], f['injections/mass2'][:]
import pycbc.pnutils
mchirp, eta = pycbc.pnutils.mass1_mass2_to_mchirp_eta(m1, m2)

foundg = found[ifar > 1000]
mbf = numpy.logical_and(mchirp[foundg] > 1.34, mchirp[foundg] > 2.17)
mbm = numpy.logical_and(mchirp[missed] > 1.34, mchirp[missed] > 2.17)
f_dist = dist[foundg][mbf]
m_dist = dist[missed][mbm]

sdist = compute_sensitive_distance(f_dist, m_dist)
print "SENSITIVE DISTANCE", sdist

# For speed don't bother plotting really distant missed points
missed = missed[dec_dist[missed] < dec_dist[found].max() * 1.1]

ifar_found = f['found_after_vetoes/ifar'][:]
color = numpy.zeros(len(found))
ten = numpy.where(ifar_found > 10)[0]
hundred = numpy.where(ifar_found > 100)[0]
thousand = numpy.where(ifar_found > 1000)[0]
color[hundred] = 0.5
color[thousand] = 1.0

fig = plot.figure()
mpoints = plot.scatter(time[missed], dec_dist[missed], marker='x', color='black', 
                         label='missed', s=60)
points = plot.scatter(time[found], dec_dist[found], c=color, s=40, 
                         linewidth=0, vmin=0, vmax=1, 
                         marker='o', label='found')
plot.xlabel('Time (s)')
plot.ylabel('Injected Decisive Distance')
plot.grid()
plot.subplots_adjust(left=0.1, right=0.8, top=0.9, bottom=0.1)
urls = pycbc.results.followup.times_to_urls(time[found], 2.0, args.injection_tag)
murls = pycbc.results.followup.times_to_urls(time[missed], 2.0, args.injection_tag)
mpld3.plugins.connect(fig, mpld3.plugins.MousePosition(fmt='.5g'))
mpld3.plugins.connect(fig, ClickLink(points, urls))
mpld3.plugins.connect(fig, ClickLink(mpoints, murls))
mpld3.plugins.connect(fig, mpld3.plugins.InteractiveLegendPlugin([mpoints, points],
                                                                 ['missed', 'found'],
                                                                 alpha_unsel=0.1))
mpld3.save_html(fig, open(args.output_file, 'w'))

fig = plot.figure()
mpoints = plot.scatter(mchirp[missed], dec_dist[missed], marker='x', 
                        color='black', label='missed', s=60)
points = plot.scatter(mchirp[found], dec_dist[found], c=color, s=40, 
                        linewidth=0, vmin=0, vmax=1, 
                         marker='o', label='found')
plot.xlabel('Mchirp')
plot.ylabel('Injected Decisive Distance')
plot.grid()
plot.subplots_adjust(left=0.1, right=0.8, top=0.9, bottom=0.1)
urls = pycbc.results.followup.times_to_urls(time[found], 2.0, args.injection_tag)
murls = pycbc.results.followup.times_to_urls(time[missed], 2.0, args.injection_tag)
mpld3.plugins.connect(fig, mpld3.plugins.MousePosition(fmt='.5g'))
mpld3.plugins.connect(fig, ClickLink(points, urls))
mpld3.plugins.connect(fig, ClickLink(mpoints, murls))

mpld3.plugins.connect(fig, mpld3.plugins.InteractiveLegendPlugin([mpoints, points],
                                                                 ['missed', 'found'],
                                                                 alpha_unsel=0.1))

oname = os.path.split(args.output_file)[0] + '/mchirp-' + os.path.split(args.output_file)[1]
mpld3.save_html(fig, open(oname, 'w'))



