#!/usr/bin/python
#
# Copyright (C) 2011 Karsten Wiesner
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General
# Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
# pycbc should follow <http://www.python.org/dev/peps/pep-0008/>
#
# vim: tabstop=4:softtabstop=4:shiftwidth=4:expandtab

#
# =============================================================================
#
#                                   Preamble
#
# =============================================================================
#

"""
Application of gravitational wave search for inspiral mergers based on the 
pycbc (py-thon c-ompact b-inary c-oalecence) package 

Single detector minimal pipeline used as prototype to test pycbc architecture
to incorporate:

- CUDA GPU implementation of CBC SPA waveform generator and 
  matched filter by Alex Nitz (Univerity of Syracuse)

- Open Cl GPU implementation of full CBC pipeline by Benjamin Somhegyi and
  Gergely Debreczeni (KFKI, RMKI Budapest)

"""

import sys
import random

from pycbc.pycbc_opencl import OpenClDeviceContext as ProccessingTargetContext

from pycbc.straindata.straindata_cpu import StrainDataCpu as StrainData 
from pycbc.matchedfilter.matchedfilter_opencl import MatchedFilterOpenCl as MatchedFilter

from pycbc.datavecterm_cpu import *
from pycbc.datavecstim_opencl import *

from pycbc.datavector.datavectoropencl import complex_vector_single_opencl_t as WaveformFrequencySeries



import logging

logging.basicConfig(level=logging.DEBUG,
                    format='%(name)s %(asctime)s %(levelname)s %(message)s',
                    filename='pycbc_min_pipeline.log',
                    filemode='w')

logger= logging.getLogger('pycbc.main_script')


start_message = 'OpenCl prototyping pipeline ...'
logger.debug(start_message)
print start_message

# setup straindata
search_time = 128 # typ design spec: 2048
sample_freq = 256 # typ design spec: 4096
length =      search_time * sample_freq
segments = 15
gps_start_time= 871147532
gps_end_time= gps_start_time + search_time
interferometer = "H1"

with ProccessingTargetContext(1) as context:
    
    strain_data= StrainData(gps_start_time, gps_end_time, 
                        segments, sample_freq, 
                        interferometer)
                        
    logger.debug("instanciated StrainData w/ segment length: {0}".format(strain_data.segments_length))

    # initialize straindata w/ noise
    for i in range(length):
        tmp= random.uniform(-1,1)
        strain_data.time_series[i] = tmp

    # convert straindata to single precision
    strain_data.convert_to_single_preci()

    # segmenting straindata and transform into frequency domain
    strain_data.perform_fft_segments()

    # create matched filter
    matched_filter = MatchedFilter(context, strain_data.segments_length, strain_data.segments_delta_x)
    logger.debug("instanciated MatchedFilter w/ length: {0}".format(matched_filter.length))

    # messy prototyping of htilde (until we have a template bank)
    htilde = WaveformFrequencySeries(context, strain_data.segments_length, strain_data.segments_delta_x)
 

    # testing the kernel: ####################################################

    from pycbc.datavector.datavectoropencl import *
    from pycbc.datavector.datavectorcpu import *

    stimulator = DataVecStimOpenCl(context)
    terminator = DataVecTermCpu(context)

    test_size= 4096

    test_mf    = MatchedFilter(context, test_size, 1.0)

    inputcpuA  = complex_vector_single_cpu_t(test_size, 1.0)
    for i in range(test_size):
        inputcpuA[i]= 2+2j
    #inputgpuA  = stimulator.data_in(inputcpuA) 
 
    inputcpuB  = complex_vector_single_cpu_t(test_size, 1.0)
    for i in range(test_size):
        inputcpuB[i]= 3+3j
    #inputgpuB  = stimulator.data_in(inputcpuB)

    outputgpu = test_mf.perform_generate_snr(inputcpuA, inputcpuB)

    outputcpu = terminator.data_in(outputgpu)

    # for i in range(test_size):
    for i in range(10):
        print "output @ index {0} = {1}".format(i, outputcpu[i])

    ###########################################################################

    print 'before hot loop'
    # hot loop
    for stilde in strain_data:
        
    	print context
        snr = matched_filter.perform_generate_snr(stilde, htilde)
        
    print 'after hot loop'    
        
    ############################################################################
    # prepare to leave the processing context (objects that contain device 
    # memory are not deleted automatically here!)
    del(strain_data)
    del(matched_filter)
    
    # leaving the ProccessingTargetContext NOW (destroy the device context)
    ############################################################################
    
end_message = '... end of OpenCl prototyping pipeline'
logger.debug(end_message)
print end_message
       




        
