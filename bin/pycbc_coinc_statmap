#!/bin/env  python
"""
The program combines coincident output files generated
by pycbc_coinc_findtrigs to generated a mapping between SNR and FAP, along
with producing the combined foreground and background triggers
"""
import argparse, h5py, numpy      
    
def load_coincs(coinc_files):
    stat1 = []
    stat2 = []s
    time1 = []
    time2 = []
    timeslide_id = []
    template_id = []
    for cfile in coinc_files:
        f = h5py.File(cfile, "r")
        stat1.append(f['coinc/stat1'])
        stat2.append(f['coinc/stat2'])
        time1.append(f['coinc/time1'])
        time2.append(f['coinc/time2'])
        timeslide_id.append(f['coinc/timeslide_id'])
        template_id.append(f['coinc/template_id'])
    return numpy.concatenate(stat1),
           numpy.concatenate(stat2),
           numpy.concatenate(time1),
           numpy.concatenate(time2),
           numpy.concatenate(timeslide_id),
           numpy.concatenate(template_id), 
           f['coinc'].attrs

def cluster_coincs(stat1, stat2, time1, time2, 
                   timeslide_id, timeslide_interval, window):
    """Cluster coincident events for each timeslide separately, across 
    templates, based on the loudest network statistic (stat1**2 + stat2**2). 
    Return the set of indices corresponding to the surviving coincidences.
    """
    indices = []
    nstatsq = stat1**2.0 + stat2**2.0
    time = (times2 + (times1 + timeslide_id * timeslide_interval)) / 2 
    time_sorting = time.argsort()
    nstatsq = nstatsq[time_sorting]
    
    timeslides = numpy.unique1d(timeslide_id)
    for timeslide in timeslides:
        locs = numpy.where(timeslid_id == timeslide)
        stime = time[locs]
        sstat = nstatsq[locs]
        
        edges = numpy.arange(stime[0], stime[-1], window)
        bins = numpy.append(numpy.searchsorted(stime, edges), len(stime))
        bins = numpy.unique1d(bins)
        
        for i in range(len(bins) - 1):
            index = numpy.argmax(sstat[bins[i], bins[i+1]) + bins[i]
            indices.append(time_sorting[locs[index]])
     return numpy.array(indices, dtype=numpy.uint32)

if __name__ == '__main__':

    parser = argparse.ArgumentParser()
    # General required options
    parser.add_argument('--coinc-files', nargs='+')
    parser.add_argument('--verbose')
    parser.add_argument('--cluster-window', type=float)
    parser.add_argument('--output-foreground')
    parser.add_argument('--output-background')
    parser.add_argument('--output-fap-map')
    args = parser.parse_args()

    if args.verbose:
        log_level = logging.INFO
        logging.basicConfig(format='%(asctime)s : %(message)s', 
                            
                                level=log_level)
    
    logging.info("Loading coinc triggers")    
    s1, s2, t1, t2, sid, tid, attr = load_coins(args.coinc_files)    
 
    logging.info("Clustering coinc triggers")
    cid = cluster_coincs(s1, s2, t1, t2, sid, 
                         attr['timeslide_interval'], 
                         args.cluster_window)
                         
    logging.info("Making FAP to STAT mapping")
    
    logging.info("Dumping foreground triggers")
    
    logging.info("Dumping background tirggers")

    logging.info("Done") 
    
