#!/usr/bin/python
""" Make table of the foreground coincident events
"""
import argparse, h5py, numpy, logging, os.path
import matplotlib
matplotlib.use('Agg')
from matplotlib.pyplot import cm
import pylab
import pycbc.pnutils, pycbc.results

parser = argparse.ArgumentParser()
parser.add_argument('--injection-file')
parser.add_argument('--bins', nargs='*')
parser.add_argument('--sig-bins', nargs='*')
parser.add_argument('--sig-type', default='ifar')
parser.add_argument('--bin-type', default='mchirp')
parser.add_argument('--min-dist', type=float)
parser.add_argument('--max-dist', type=float)
parser.add_argument('--verbose', action='count')
parser.add_argument('--method', choices=['pylal', 'shell', 'mc'], default='pylal')
parser.add_argument('--dist-bins', type=int, default=100)
parser.add_argument('--output-file')
args = parser.parse_args()

def volume_montecarlo(found_d, missed_d, found_mchirp, missed_mchirp, distance_param, distance_distribution):
    """ Compute the sensitive volume and standard error using a direct
    Monte Carlo integral

    Parameters
    -----------
    distance_param: 
        Parameter of the injections used to generate a distribution over distance.
        -may be 'distance', 'chirp_distance".
    distance_distribution: 
        form of the distribution over the parameter
      - may be 'log' (uniform in log D), 'uniform' (uniform in D), '
        distancesquared' (uniform in D**2),
        'volume' (uniform in D***3)
      - It is assumed that injections were carried out over a range of D such 
      that the sensitive
        volume due to signals at distance below D_min is negligible and the 
        efficiency at distances
        above D_max is negligibly small
    """
    d_weight_power = {
        'log'             : 3.,
        'uniform'         : 2.,
        'distancesquared' : 1.,
        'volume'          : 0.
    }[distance_distribution]
    # if no max distance param given, use maximum physical distance actually injected
    max_distance = max(numpy.max(found_d), numpy.max(missed_d))

    # all montecarlo integrals are proportional to the volume out to max_distance
    montecarlo_vtot = (4. / 3.) * numpy.pi * max_distance ** 3.

    # set up arrays of weights for the MC average of efficiency
    if distance_param == 'distance':
        found_weights = found_d ** d_weight_power
        missed_weights = missed_d ** d_weight_power
        
    elif distance_param == 'chirp_distance':
        mchirp_weight_power = {
            'log'             : 0.,
            'uniform'         : 5. / 6.,
            'distancesquared' : 5. / 3.,
            'volume'          : 15. / 6.
        }[distance_distribution]
        
        # for a distribution over dchirp, weights get a power of mchirp to rescale
        # the injection density to the target mass distribution
        found_weights = found_d ** d_weight_power * found_mchirp ** mchirp_weight_power
        missed_weights = missed_d ** d_weight_power * missed_mchirp ** mchirp_weight_power
    else: 
        raise NotImplementedError("%s is not a recognized distance parameter" % distance_param)

    # measured weighted efficiency is w_i for a found inj and 0 for missed
    mc_weight_samples = numpy.concatenate((found_weights, 0*missed_weights))

    # MC integral is total volume of sphere times sum of found weights over sum of all weights
    # Treat (total volume / sum of weights) as a constant prefactor
    mc_norm = sum(found_weights) + sum(missed_weights)
    mc_prefactor = montecarlo_vtot / mc_norm
    mc_sum = sum(mc_weight_samples)

    # Sample variance of injection efficiency: mean of the square - square of the mean
    Ninj = len(mc_weight_samples)
    mc_sample_variance = sum(mc_weight_samples ** 2.) / Ninj - (mc_sum / Ninj) ** 2.
    # Variance of sum over efficiencies scales up with Ninj (Bienayme' rule)
    mc_sum_variance = Ninj * mc_sample_variance

    # return MC integral and its standard deviation
    return mc_prefactor * mc_sum, mc_prefactor * mc_sum_variance ** 0.5

def compute_efficiency_bins_pylal(f_dist, m_dist, bins=15):
    def sims_to_bin(sim):
        return (sim, 0)

    from pylal import rate
    from pylal.imr_utils import compute_search_volume_in_bins, compute_search_efficiency_in_bins
    found = f_dist
    
    total = numpy.concatenate([f_dist, m_dist])
    ndbins = rate.NDBins([rate.LinearBins(min(total), max(total), bins), rate.LinearBins(0., 1, 1)])
    
    vol, verr = compute_search_volume_in_bins(found, total, ndbins, sims_to_bin)

    vol, verr = vol.array[0], verr.array[0]
    d_high = ((vol + verr) * 3.0/4.0/numpy.pi) ** (1.0/3.0)
    d_low = ((vol - verr) * 3.0/4.0/numpy.pi) ** (1.0/3.0)
    dist = (vol * 3.0/4.0/numpy.pi) ** (1.0/3.0)
    return dist, dist - d_low, d_high - dist

def compute_sensitive_distance(f_dist, m_dist):
    """ Compute the sensitive volume
    """
    f_dist.sort()
    m_dist.sort()
    distances = numpy.concatenate([f_dist, m_dist])
    dist_sorting = distances.argsort()
    distances = distances[dist_sorting]
    low = 0
    vol = 0
    vol_err = 0
    for i in range(len(distances)):
        if i == len(distances) - 1:
            break
    
        high = (distances[i+1] + distances[i]) / 2
        bin_width = high - low
        
        if dist_sorting[i] < len(f_dist):
            vol += 4 * numpy.pi * distances[i]**2.0 * bin_width
            vol_err += (4 * numpy.pi * distances[i]**2.0 * bin_width)**2.0
        low = high
    vol_err = vol_err ** 0.5
    d_high = ((vol + vol_err) * 3.0/4.0/numpy.pi) ** (1.0/3.0)
    d_low = ((vol - vol_err) * 3.0/4.0/numpy.pi) ** (1.0/3.0)
    dist = (vol * 3.0/4.0/numpy.pi) ** (1.0/3.0)
    return dist, dist - d_low, d_high - dist

if args.verbose:
    log_level = logging.INFO
    logging.basicConfig(format='%(asctime)s : %(message)s', level=log_level)
    
logging.info('Read in the data')
f = h5py.File(args.injection_file, 'r')

time = f['injections/end_time'][:]
found = f['found_after_vetoes/injection_index'][:]
missed = f['missed/after_vetoes'][:]

m1, m2 = f['injections/mass1'][:], f['injections/mass2'][:]
mchirp, eta = pycbc.pnutils.mass1_mass2_to_mchirp_eta(m1, m2)

# This hardcodes HL search !!!!!, replace with function that takes or/sky/det
hdist = f['injections/eff_dist_h'][:]
ldist = f['injections/eff_dist_l'][:]
dec_dist = numpy.maximum(hdist, ldist)
dist = f['injections/distance'][:]
m1, m2 = f['injections/mass1'][:], f['injections/mass2'][:]
s1z, s2z = f['injections/spin1z'][:], f['injections/spin2z'][:]
s1x, s2x = f['injections/spin1x'][:], f['injections/spin2x'][:]
s1y, s2y = f['injections/spin1y'][:], f['injections/spin2y'][:]
inc = f['injections/inclination'][:]
mchirp, eta = pycbc.pnutils.mass1_mass2_to_mchirp_eta(m1, m2)

# Dict to hold possible bin types
values = {}
values['mchirp'] = mchirp
values['eta'] = eta
values['total_mass'] = m1 + m2

s1 = s1x * numpy.sin(inc) + s1z * numpy.cos(inc)
s2 = s2x * numpy.sin(inc) + s2z * numpy.cos(inc)

values['spin'] = (m1 * s1 + m2 * s2) / (m1 + m2)
labels = {}
labels['mchirp'] = "$ M_{chirp} \in [%5.2f, %5.2f] M_\odot $"
labels['total_mass'] = "$ M_{total} \in [%5.2f, %5.2f] M_\odot $"
labels['spin'] = "$Eff Spin \in [%5.2f, %5.2f] $"

if args.sig_type == 'ifar':
    ifar = f['found_after_vetoes/ifar'][:]
    ifar_exc = f['found_after_vetoes/ifar_exc'][:]
    xlabel = 'Inverse False Alarm Rate (years)'
    if args.sig_bins:
        ifar_values = [float(v) for v in args.sig_bins]
    else:
        ifar_values = 10 ** (numpy.arange(0, 4, .05))
elif args.sig_type == 'fap':
    fap = f['found_after_vetoes/fap'][:]
    fap_exc = f['found_after_vetoes/fap_exc'][:]
    xlabel = 'False Alarm Propability'
    ifar = fap
    ifar_exc = fap_exc
    if args.sig_bins:
        ifar_values = [float(v) for v in args.sig_bins]
    else:
        ifar_values = [1.0, .1, .01, .001, .001]
else:
    raise ValueErorr('Invalid Significance Axis Type (choose fap or ifar)')
   
color=iter(cm.rainbow(numpy.linspace(0, 1 , len(args.bins)-1)))
fvalues = [ifar, ifar_exc]
do_labels = [True, False]
alphas = [.8, .3]

fig = pylab.figure()

for j in range(len(args.bins)-1):
    c = next(color)
    for fval, do_label, alpha in zip(fvalues, do_labels, alphas):
        left =  float(args.bins[j])
        right = float(args.bins[j+1])
        binval = values[args.bin_type]

        mbm = numpy.logical_and(binval[missed] > left, binval[missed] < right)
        m_dist = dist[missed][mbm]

        if len(m_dist) < 2:
            continue

        dists, low_errors, high_errors = [], [], []

        for ifar_value in ifar_values:
            if args.sig_type == 'ifar':
                foundg = found[fval >= ifar_value]
            else:
                foundg = found[fval <= ifar_value]
                
            mbf = numpy.logical_and(binval[foundg] > left, binval[foundg] < right)
            f_dist = dist[foundg][mbf]
            
            foundm = found[fval < ifar_value]
            mbfm = numpy.logical_and(binval[foundm] > left, binval[foundm] < right)
            f_distm = dist[foundm][mbfm]
            
            m_dist_full = numpy.append(m_dist, f_distm)
            
            if args.method == 'shell': 
                sdist, elow, ehigh = compute_sensitive_distance(f_dist, m_dist_full)
            elif args.method == 'pylal':
                sdist, elow, ehigh = compute_efficiency_bins_pylal(f_dist, m_dist_full, bins=args.dist_bins)
            elif args.method == 'mc':
                sdist, elow, ehigh = volume_montecarlo(f_dist, m_dist)

            dists.append(sdist)
            low_errors.append(elow)
            high_errors.append(ehigh)
            
        label = labels[args.bin_type] % (left, right) if do_label else None
        pylab.plot(ifar_values, dists, label=label, c=c)
        pylab.plot(ifar_values, dists, alpha=alpha, c='black')
        pylab.fill_between(ifar_values, 
                           dists - numpy.array(low_errors), 
                           dists + numpy.array(high_errors), 
                           facecolor=c, edgecolor=c, alpha=alpha)
                           
ax = pylab.gca()
ax.set_xscale('log')

if args.sig_type == 'fap':
    ax.invert_xaxis()

pylab.ylabel('Sensitive Distance (Mpc)')
pylab.xlabel(xlabel)

if args.min_dist:
    pylab.ylim(args.min_dist, args.max_dist)

pylab.grid()  
pylab.legend(loc='lower left')
pycbc.results.save_fig_with_metadata(fig, args.output_file, 
                                     title='%s binning' % args.bin_type, 
                                     caption='')
