#!/usr/bin/python
""" Make table of the foreground coincident events
"""
import argparse, h5py, numpy, logging, os.path
import matplotlib
matplotlib.use('Agg')
from matplotlib.pyplot import cm
import pylab, pycbc.pnutils, pycbc.results, pycbc
from pycbc import sensitivity

parser = argparse.ArgumentParser()
parser.add_argument('--injection-file')
parser.add_argument('--bins', nargs='*')
parser.add_argument('--sig-bins', nargs='*')
parser.add_argument('--sig-type', default='ifar')
parser.add_argument('--bin-type', default='mchirp')
parser.add_argument('--min-dist', type=float)
parser.add_argument('--max-dist', type=float)
parser.add_argument('--verbose', action='count')
parser.add_argument('--method', choices=['pylal', 'shell', 'mc'], default='pylal')
parser.add_argument('--dist-bins', type=int, default=100)
parser.add_argument('--distance-param', type=str)
parser.add_argument('--distance-distribution', type=str)
parser.add_argument('--output-file')
args = parser.parse_args()

if args.verbose:
    log_level = logging.INFO
    logging.basicConfig(format='%(asctime)s : %(message)s', level=log_level)
    
logging.info('Read in the data')
f = h5py.File(args.injection_file, 'r')

time = f['injections/end_time'][:]
found = f['found_after_vetoes/injection_index'][:]
missed = f['missed/after_vetoes'][:]

m1, m2 = f['injections/mass1'][:], f['injections/mass2'][:]
mchirp, eta = pycbc.pnutils.mass1_mass2_to_mchirp_eta(m1, m2)

# This hardcodes HL search !!!!!, replace with function that takes or/sky/det
hdist = f['injections/eff_dist_h'][:]
ldist = f['injections/eff_dist_l'][:]
dec_dist = numpy.maximum(hdist, ldist)
dist = f['injections/distance'][:]
m1, m2 = f['injections/mass1'][:], f['injections/mass2'][:]
s1z, s2z = f['injections/spin1z'][:], f['injections/spin2z'][:]
s1x, s2x = f['injections/spin1x'][:], f['injections/spin2x'][:]
s1y, s2y = f['injections/spin1y'][:], f['injections/spin2y'][:]
inc = f['injections/inclination'][:]
mchirp, eta = pycbc.pnutils.mass1_mass2_to_mchirp_eta(m1, m2)

# Dict to hold possible bin types
values = {}
values['mchirp'] = mchirp
values['eta'] = eta
values['total_mass'] = m1 + m2

s1 = s1x * numpy.sin(inc) + s1z * numpy.cos(inc)
s2 = s2x * numpy.sin(inc) + s2z * numpy.cos(inc)

values['spin'] = (m1 * s1 + m2 * s2) / (m1 + m2)
labels = {}
labels['mchirp'] = "$ M_{chirp} \in [%5.2f, %5.2f] M_\odot $"
labels['total_mass'] = "$ M_{total} \in [%5.2f, %5.2f] M_\odot $"
labels['spin'] = "$Eff Spin \in [%5.2f, %5.2f] $"

if args.sig_type == 'ifar':
    ifar = f['found_after_vetoes/ifar'][:]
    ifar_exc = f['found_after_vetoes/ifar_exc'][:]
    xlabel = 'Inverse False Alarm Rate (years)'
    if args.sig_bins:
        ifar_values = [float(v) for v in args.sig_bins]
    else:
        ifar_values = 10 ** (numpy.arange(0, 4, .05))
elif args.sig_type == 'fap':
    fap = f['found_after_vetoes/fap'][:]
    fap_exc = f['found_after_vetoes/fap_exc'][:]
    xlabel = 'False Alarm Propability'
    ifar = fap
    ifar_exc = fap_exc
    if args.sig_bins:
        ifar_values = [float(v) for v in args.sig_bins]
    else:
        ifar_values = [1.0, .1, .01, .001, .001]
else:
    raise ValueErorr('Invalid Significance Axis Type (choose fap or ifar)')
   
color=iter(cm.rainbow(numpy.linspace(0, 1 , len(args.bins)-1)))
fvalues = [ifar, ifar_exc]
do_labels = [True, False]
alphas = [.8, .3]

fig = pylab.figure()

for j in range(len(args.bins)-1):
    c = next(color)
    for fval, do_label, alpha in zip(fvalues, do_labels, alphas):
        left =  float(args.bins[j])
        right = float(args.bins[j+1])
        binval = values[args.bin_type]

        mbm = numpy.logical_and(binval[missed] > left, binval[missed] < right)
        m_dist = dist[missed][mbm]

        if len(m_dist) < 2:
            continue

        dists, low_errors, high_errors = [], [], []

        for ifar_value in ifar_values:
            if args.sig_type == 'ifar':
                foundg = found[fval >= ifar_value]
            else:
                foundg = found[fval <= ifar_value]
                
            mbf = numpy.logical_and(binval[foundg] > left, binval[foundg] < right)
            f_dist = dist[foundg][mbf]
            
            foundm = found[fval < ifar_value]
            mbfm = numpy.logical_and(binval[foundm] > left, binval[foundm] < right)
            f_distm = dist[foundm][mbfm]
            
            m_dist_full = numpy.append(m_dist, f_distm)
            
            
            if args.method == 'shell': 
                vol, vol_err = sensitivity.volume_shell(f_dist, m_dist_full)
            elif args.method == 'pylal':
                vol, vol_err = sensitivity.volume_pylal(f_dist, m_dist_full, bins=args.dist_bins)
            elif args.method == 'mc':
                found_mchirp = mchirp[foundg][mbf]
                missed_mchirp = numpy.append(mchirp[missed][mbm], mchirp[foundm][mbfm])
                vol, vol_err = sensitivity.volume_montecarlo(f_dist, m_dist_full, 
                       found_mchirp, missed_mchirp,
                       args.distance_param, args.distance_distribution)
                   
            sdist, ehigh, elow = sensitivity.volume_to_distance_with_errors(vol, vol_err)
                        
            dists.append(sdist)
            low_errors.append(elow)
            high_errors.append(ehigh)
            
        label = labels[args.bin_type] % (left, right) if do_label else None
        pylab.plot(ifar_values, dists, label=label, c=c)
        pylab.plot(ifar_values, dists, alpha=alpha, c='black')
        pylab.fill_between(ifar_values, 
                           dists - numpy.array(low_errors), 
                           dists + numpy.array(high_errors), 
                           facecolor=c, edgecolor=c, alpha=alpha)
                           
ax = pylab.gca()
ax.set_xscale('log')

if args.sig_type == 'fap':
    ax.invert_xaxis()

pylab.ylabel('Sensitive Distance (Mpc)')
pylab.xlabel(xlabel)

if args.min_dist:
    pylab.ylim(args.min_dist, args.max_dist)

pylab.grid()  
pylab.legend(loc='lower left')
pycbc.results.save_fig_with_metadata(fig, args.output_file, 
                                     title='%s binning' % args.bin_type, 
                                     caption='')
