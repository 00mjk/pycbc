#!/usr/bin/python
#
# pycbc should follow <http://www.python.org/dev/peps/pep-0008/>
#
# vim: tabstop=4:softtabstop=4:shiftwidth=4:expandtab

import sys
# preliminary hard coded path to packages 
sys.path.append('/Users/kawies/dev/src/pycbc')

#import pycbc
#
#    pycbc.data_vec         module defining data
from pycbc.datavector.datavector_opencl import DataVectorOpenCl as DataVector 
from pycbc.matchedfilter.matchedfilter_opencl import MatchedFilterOpenCl as MatchedFilter
#    pycbc.template_bank    module defining the template banks
#    pycbc.chisq_veto       module defining the chisq vetos
#    pycbc.events           module defining handling of events
#
#
# 

#Leo: Recurse over generators, keyword arguments
#
#  for buffer in inject(read_frames(cache), injections)
#  or 
#  for trigger in xcorr (inject(read_frames(cache), injections), bank)

htilde = DataVector(2, 3, 4000)
print htilde

matched_filter = MatchedFilter(htilde)
print matched_filter

exit()

#
# create classes needed by filtering engine
#

#class TaylorF2Template(pycbc.TaylorF2Template, pycbc.TaylorF2TemplateGPU):
#    def __init__(self):
#        pycbc.TaylorF2Template.__init__(self)
#        pycbc.TaylorF2TemplateGPU.__init__(self)

#class TemplateBank(pycbc.TemplateBank, pycbc.TemplateBankGPU,
#                   TaylorF2Template):
#    def __init__(self):
#        pycbc.TemplateBank.__init__(self)
#        pycbc.TemplateBankGPU.__init__(self)
#        TaylorF2Template.__init__(self)

#class ChisqVeto(pycbc.ChisqVeto, pycbc.ChisqVetoGPU):
#    def __init__(self):
#        pass

#class SingleDetectorEvent(pycbc.SingleDetectorEvent, 
#                          pycbc.SingleDetectorEventGPU):
#    def __init__(self):
#        pass

#
# main program for the filtering
#

# read the input h(t) from a single detector
data = pycbc.StrainData()
data.read_frames("H1:LSC-STRAIN", t_start, t_end, "/path/to/cache.txt")

# perform software injections
injections = pycbc.Injector("/path/to/injections.xml")
injections.inject(data)

# reseample the data to the desired rate
resample_filter = pycbc.Resampler(data.dt)
resample_filter.resample(data, output_dt)

# high pass the strain data to avoid dynamic range problems
high_pass_filter = pycbc.ForwardsBackwardsButterworthFilter()
high_pass_filter.high_pass(data, 35.0, 8)

# convert the data to a four-byte floating point number
data.to_float()

# create the overwhitening filter
psd = pycbc.Spectrum(delta_t, N)
psd.power_spectrum(data, "medianmean", "hanning", 256, 128)
psd.inverse()
psd.truncate(16)

# create the overwhitened data segments in the frequency domain
data.fft_segments(256, 128)
data *= psd

# create a template bank to filter against
bank = TemplateBank()
bank.read( "/path/to/templates.xml" )

# apply any template-specific data preconditioning
data *= bank.condition_data()

# create the objects needed to perform the filtering
matched_filter = MatchedFilter( data )
chisq_veto = ChisqVeto( 15, psd )
events = SingleDetectorEvent()

# filter the data against the template bank
for htilde in bank:
    htilde.generate_filter_waveform()
    chisq.compute_frequency_bins(htilde)
    for stilde in data:
        matched_filter.generate_snr( stilde, htilde )
        if matched_filter.max() > 5.5:
            chisq_veto.generate_chisq( matched_filter )
            events.find_events( htilde, matched_filter, chisq_veto )

# cluster the events across the template bank
events.cluster_events( 0.1 )
events.write( "/path/to/output.xml" )
